# Path to the input file with computer names (one per line)
$inputFile = "C:\Path\To\Computers.txt"

# Read the computer names from the input file
$computerNames = Get-Content -Path $inputFile

# Define the script block
$scriptBlock = {
    param($ComputerName)

    # Get all shared folders
    $shares = Get-WmiObject -Class Win32_Share -ComputerName $ComputerName

    # Filter out default administrative shares like C$, D$, ADMIN$, IPC$
    $userDefinedShares = $shares | Where-Object { $_.Name -notmatch '^\$|ADMIN\$|IPC\$' }

    # Loop through each user-defined share
    foreach ($share in $userDefinedShares) {
        Write-Host "Computer: $ComputerName"
        Write-Host "Share Name: $($share.Name)"
        Write-Host "Path: $($share.Path)"
        Write-Host "Description: $($share.Description)"
        Write-Host "--------------------------------"

        # Get Share permissions using WMI (Win32_LogicalShareSecuritySetting)
        $sharePermissions = Get-WmiObject -Query "SELECT * FROM Win32_LogicalShareSecuritySetting WHERE Name = '$($share.Name)'" -ComputerName $ComputerName

        $accessList = $sharePermissions.GetSecurityDescriptor().Descriptor.DACL
        foreach ($access in $accessList) {
            $trustee = $access.Trustee.Name
            $accessMask = $access.AccessMask

            # Convert AccessMask to readable permissions
            $permissionsReadable = Switch ($accessMask) {
                2032127 { "Full Control" }
                1245631 { "Change" }
                1179817 { "Read" }
                Default { "Unknown" }
            }

            Write-Host "User/Group: $trustee"
            Write-Host "Permissions: $permissionsReadable"
            Write-Host "--------------------------------"
        }

        # Get NTFS permissions for the folder
        try {
            $acl = Get-Acl $share.Path
            $acl.Access | ForEach-Object {
                Write-Host "NTFS Permissions for $($_.IdentityReference): $($_.FileSystemRights)"
            }
        } catch {
            Write-Host "Failed to get NTFS permissions for path: $($share.Path)"
        }

        Write-Host "--------------------------------`n"
    }
}

# Loop through each computer name in the input file
foreach ($computer in $computerNames) {
    # Invoke the script block for each computer
    Invoke-Command -ScriptBlock $scriptBlock -ArgumentList $computer
}
---->
# Define the input parameters
$computerName = "localhost"  # Change to remote computer if needed
$shares = @("Share1", "Share2")  # List of share names
$userOrGroup = "DOMAIN\UserOrGroup"  # Specify the user or group to grant Full Control

# Define the script block to set full control on shares
$scriptBlock = {
    param($ComputerName, $Shares, $UserOrGroup)

    foreach ($shareName in $Shares) {
        # Retrieve the share details
        $share = Get-WmiObject -Class Win32_Share -Filter "Name = '$shareName'" -ComputerName $ComputerName

        if ($share) {
            Write-Host "Processing share: $($share.Name) on $ComputerName"

            # Get the current security descriptor for the share
            $shareSecurity = Get-WmiObject -Query "SELECT * FROM Win32_LogicalShareSecuritySetting WHERE Name = '$($share.Name)'" -ComputerName $ComputerName

            if ($shareSecurity) {
                # Get the current security descriptor
                $sd = $shareSecurity.GetSecurityDescriptor().Descriptor

                # Define a new Access Control Entry (ACE) for full control
                $ace = New-Object System.Management.ManagementBaseObject ($sd.DACL[0].Clone())
                $ace.Trustee.Name = $UserOrGroup
                $ace.Trustee.Domain = $null
                $ace.Trustee.SidString = $null
                $ace.Trustee.Sid = $null
                $ace.AccessMask = 2032127  # Full Control
                $ace.AceFlags = 3  # Inheritance
                $ace.AceType = 0  # Allow

                # Add the new ACE to the security descriptor
                $sd.DACL += $ace

                # Apply the updated security descriptor
                $shareSecurity.SetSecurityDescriptor($sd)
                Write-Host "Full control granted to $UserOrGroup on $($share.Name)"
            } else {
                Write-Host "Failed to retrieve security descriptor for $($share.Name)"
            }
        } else {
            Write-Host "Share $shareName not found on $ComputerName"
        }
    }
}

# Invoke the script block with target shares
Invoke-Command -ScriptBlock $scriptBlock -ArgumentList $computerName, $shares, $userOrGroup
-------------------------------
provider "aws" {
  region = "us-east-1"
}

# existing VPC and Subnets
variable "vpc_id" {
  description = "Already created VPCID"
}

variable "subnet_ids" {
  description = "Already created Subnetid"
  type        = list(string)
}

# Define Security Group
resource "aws_security_group" "aurora_sg" {
  vpc_id = var.vpc_id

  ingress {
    from_port   = 3306
    to_port     = 3306
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Aurora DB Cluster
resource "aws_rds_cluster" "aurora_cluster" {
  cluster_identifier      = "aurora-cluster"
  engine                  = "aurora-mysql"
  engine_version          = "5.7.mysql_aurora.2.08.1"
  master_username         = "admin"
  master_password         = "mypassword123"
  database_name           = "main_db"
  db_subnet_group_name    = aws_db_subnet_group.aurora_subnets.name
  vpc_security_group_ids  = [aws_security_group.aurora_sg.id]

  skip_final_snapshot = true
}

# Subnet Group -  Existing Subnets
resource "aws_db_subnet_group" "aurora_subnets" {
  name       = "aurora-subnet-group"
  subnet_ids = var.subnet_ids
}

# Aurora DB Instance 1
resource "aws_rds_cluster_instance" "aurora_instance_1" {
  identifier              = "aurora-instance-1"
  cluster_identifier      = aws_rds_cluster.aurora_cluster.id
  instance_class          = "db.r5.large"
  engine                  = aws_rds_cluster.aurora_cluster.engine
  db_subnet_group_name    = aws_db_subnet_group.aurora_subnets.name
}

# Aurora DB Instance 2
resource "aws_rds_cluster_instance" "aurora_instance_2" {
  identifier              = "aurora-instance-2"
  cluster_identifier      = aws_rds_cluster.aurora_cluster.id
  instance_class          = "db.r5.large"
  engine                  = aws_rds_cluster.aurora_cluster.engine
  db_subnet_group_name    = aws_db_subnet_group.aurora_subnets.name
}

# First DB creating in cluster
resource "aws_rds_cluster_parameter_group" "aurora_pg" {
  name   = "aurora-pg"
  family = "aurora-mysql5.7"
}

resource "aws_rds_cluster" "aurora_db_1" {
  cluster_identifier      = "aurora-db-1"
  engine                  = "aurora-mysql"
  engine_version          = "5.7.mysql_aurora.2.08.1"
  master_username         = "admin"
  master_password         = "mypassword123"
  database_name           = "database1"
  db_subnet_group_name    = aws_db_subnet_group.aurora_subnets.name
  vpc_security_group_ids  = [aws_security_group.aurora_sg.id]
  skip_final_snapshot     = true
}

# Second DB creating in cluster
resource "aws_rds_cluster" "aurora_db_2" {
  cluster_identifier      = "aurora-db-2"
  engine                  = "aurora-mysql"
  engine_version          = "5.7.mysql_aurora.2.08.1"
  master_username         = "admin"
  master_password         = "mypassword123"
  database_name           = "database2"
  db_subnet_group_name    = aws_db_subnet_group.aurora_subnets.name
  vpc_security_group_ids  = [aws_security_group.aurora_sg.id]
  skip_final_snapshot     = true
}


------
# Define the provider
provider "aws" {
  region = "us-west-2" # Give region name
}

# Getting the existing Aurora DB cluster
data "aws_rds_cluster" "existing_cluster" {
  cluster_identifier = "existing-cluster-id" # Give your exiting cluster ID
}

# Getting the existing security group for the cluster 
data "aws_security_group" "existing_sg" {
  id = "sg-xxxxxxx" # Give your exising security group ID
}

# Getting the existing subnet group (optional if you know the subnet group ID)
data "aws_db_subnet_group" "existing_subnet_group" {
  name = "your-db-subnet-group" # Replace with your existing subnet group
}

# creating a new DB instance and add it to existing cluster
resource "aws_rds_cluster_instance" "new_db_instance" {
  identifier             = "new-db-instance-01"   # Identifier for new DB instance
  cluster_identifier     = data.aws_rds_cluster.existing_cluster.id  # We are poinitng to the existing cluster
  instance_class         = "db.r5.large"  # Choose required instance type
  engine                 = "aurora-mysql"  # Choose the required engine
  db_subnet_group_name   = data.aws_db_subnet_group.existing_subnet_group.name
  publicly_accessible    = false   # Set as per your needs to available publicly or not.
  apply_immediately      = true    # Apply changes immediately
  auto_minor_version_upgrade = true

  # Use the existing security group
  vpc_security_group_ids = [data.aws_security_group.existing_sg.id]

  # Optional tags
  tags = {
    Name = "New DB Instance"
    Environment = "Testing"
  }
}
-----> copy from here<-----------------
# Replace with your server names
$servers = @("Server1", "Server2", "Server3")

foreach ($server in $servers) {
    try {
        $sessions = Get-CimInstance -ClassName Win32_ComputerSystem -ComputerName $server
        $loggedOnUsers = $sessions.UserName

        if ($loggedOnUsers) {
            Write-Output "$server: $loggedOnUsers"
        } else {
            Write-Output "$server: No users logged on"
        }
    } catch {
        Write-Output "Could not connect to $server: $_"
    }
}


-->
# Replace with your server names
$servers = @("Server1", "Server2", "Server3")

foreach ($server in $servers) {
    try {
        $output = quser /server:$server 2>&1
        Write-Output "$server:"
        Write-Output $output
    } catch {
        Write-Output "Could not connect to $server: $_"
    }
}


-->
# Replace with your server names
$servers = @("Server1", "Server2", "Server3")

foreach ($server in $servers) {
    try {
        $users = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $server
        Write-Output "$server: $($users.UserName)"
    } catch {
        Write-Output "Could not connect to $server: $_"
    }
}

---->   <--------------------
# Replace with your server names
$servers = @("Server1", "Server2", "Server3")

# Initialize an array to hold the output
$htmlOutput = @()

# Start the HTML content
$htmlOutput += "<html><head><title>Logged On Users</title></head><body>"
$htmlOutput += "<h1>Logged On Users Report</h1>"
$htmlOutput += "<table border='1'><tr><th>Server</th><th>Logged On Users</th></tr>"

foreach ($server in $servers) {
    try {
        $output = quser /server:$server 2>&1

        # Check if there are logged on users
        if ($output -match "No User exists") {
            # If no user is logged on, add a blank entry for that server
            $htmlOutput += "<tr><td>$server</td><td></td></tr>"
        } else {
            # Parse the output to get the logged on users
            $loggedOnUsers = $output | Select-String -Pattern '^\s*([^\s]+)\s+' | ForEach-Object {
                $_ -replace '^\s*([^\s]+)\s+', '$1'
            } -join ", "

            # Add the server and logged on users to the HTML output
            $htmlOutput += "<tr><td>$server</td><td>$loggedOnUsers</td></tr>"
        }
    } catch {
        # If there is a connection error, add a blank entry for that server
        $htmlOutput += "<tr><td>$server</td><td></td></tr>"
    }
}

# End the HTML content
$htmlOutput += "</table></body></html>"

# Specify the output file location
$outputFile = "C:\Path\To\Your\Directory\LoggedOnUsersReport.html"  # Change this to your desired path

# Save the HTML output to a file
$htmlOutput | Out-File -FilePath $outputFile -Encoding UTF8

# Inform the user where the report is saved
Write-Output "Report saved to $outputFile"
