# Path to the input file with computer names (one per line)
$inputFile = "C:\Path\To\Computers.txt"

# Read the computer names from the input file
$computerNames = Get-Content -Path $inputFile

# Define the script block
$scriptBlock = {
    param($ComputerName)

    # Get all shared folders
    $shares = Get-WmiObject -Class Win32_Share -ComputerName $ComputerName

    # Filter out default administrative shares like C$, D$, ADMIN$, IPC$
    $userDefinedShares = $shares | Where-Object { $_.Name -notmatch '^\$|ADMIN\$|IPC\$' }

    # Loop through each user-defined share
    foreach ($share in $userDefinedShares) {
        Write-Host "Computer: $ComputerName"
        Write-Host "Share Name: $($share.Name)"
        Write-Host "Path: $($share.Path)"
        Write-Host "Description: $($share.Description)"
        Write-Host "--------------------------------"

        # Get Share permissions using WMI (Win32_LogicalShareSecuritySetting)
        $sharePermissions = Get-WmiObject -Query "SELECT * FROM Win32_LogicalShareSecuritySetting WHERE Name = '$($share.Name)'" -ComputerName $ComputerName

        $accessList = $sharePermissions.GetSecurityDescriptor().Descriptor.DACL
        foreach ($access in $accessList) {
            $trustee = $access.Trustee.Name
            $accessMask = $access.AccessMask

            # Convert AccessMask to readable permissions
            $permissionsReadable = Switch ($accessMask) {
                2032127 { "Full Control" }
                1245631 { "Change" }
                1179817 { "Read" }
                Default { "Unknown" }
            }

            Write-Host "User/Group: $trustee"
            Write-Host "Permissions: $permissionsReadable"
            Write-Host "--------------------------------"
        }

        # Get NTFS permissions for the folder
        try {
            $acl = Get-Acl $share.Path
            $acl.Access | ForEach-Object {
                Write-Host "NTFS Permissions for $($_.IdentityReference): $($_.FileSystemRights)"
            }
        } catch {
            Write-Host "Failed to get NTFS permissions for path: $($share.Path)"
        }

        Write-Host "--------------------------------`n"
    }
}

# Loop through each computer name in the input file
foreach ($computer in $computerNames) {
    # Invoke the script block for each computer
    Invoke-Command -ScriptBlock $scriptBlock -ArgumentList $computer
}
---->
# Define the input parameters
$computerName = "localhost"  # Change to remote computer if needed
$shares = @("Share1", "Share2")  # List of share names
$userOrGroup = "DOMAIN\UserOrGroup"  # Specify the user or group to grant Full Control

# Define the script block to set full control on shares
$scriptBlock = {
    param($ComputerName, $Shares, $UserOrGroup)

    foreach ($shareName in $Shares) {
        # Retrieve the share details
        $share = Get-WmiObject -Class Win32_Share -Filter "Name = '$shareName'" -ComputerName $ComputerName

        if ($share) {
            Write-Host "Processing share: $($share.Name) on $ComputerName"

            # Get the current security descriptor for the share
            $shareSecurity = Get-WmiObject -Query "SELECT * FROM Win32_LogicalShareSecuritySetting WHERE Name = '$($share.Name)'" -ComputerName $ComputerName

            if ($shareSecurity) {
                # Get the current security descriptor
                $sd = $shareSecurity.GetSecurityDescriptor().Descriptor

                # Define a new Access Control Entry (ACE) for full control
                $ace = New-Object System.Management.ManagementBaseObject ($sd.DACL[0].Clone())
                $ace.Trustee.Name = $UserOrGroup
                $ace.Trustee.Domain = $null
                $ace.Trustee.SidString = $null
                $ace.Trustee.Sid = $null
                $ace.AccessMask = 2032127  # Full Control
                $ace.AceFlags = 3  # Inheritance
                $ace.AceType = 0  # Allow

                # Add the new ACE to the security descriptor
                $sd.DACL += $ace

                # Apply the updated security descriptor
                $shareSecurity.SetSecurityDescriptor($sd)
                Write-Host "Full control granted to $UserOrGroup on $($share.Name)"
            } else {
                Write-Host "Failed to retrieve security descriptor for $($share.Name)"
            }
        } else {
            Write-Host "Share $shareName not found on $ComputerName"
        }
    }
}

# Invoke the script block with target shares
Invoke-Command -ScriptBlock $scriptBlock -ArgumentList $computerName, $shares, $userOrGroup
